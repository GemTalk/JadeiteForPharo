"
documentPresenter & codePane are identical as ported code from Dolphin used both. 
"
Class {
	#name : 'JadeiteInspector',
	#superclass : 'JadeInspector',
	#traits : 'JadeiteToolbarTrait',
	#classTraits : 'JadeiteToolbarTrait classTrait',
	#instVars : [
		'statusTextPresenter',
		'codePane',
		'model',
		'documentPresenter',
		'toolbar',
		'oopsCollection',
		'objectIndex'
	],
	#category : 'JadeiteInspector'
}

{ #category : 'as yet unclassified' }
JadeiteInspector class >> resource_Default_view [
	"Answer the literal data from which the 'Default view' resource can be reconstituted.
	DO NOT EDIT OR RECATEGORIZE THIS METHOD.

	If you wish to modify this resource evaluate:
	ViewComposer openOn: (ResourceIdentifier class: self selector: #resource_Default_view)
	"

	^#(#'!STL' 4 788558 10 ##(Smalltalk.STBViewProxy) ##(Smalltalk.ShellView) 34 27 nil nil 8 #(13565952 65536) 416 nil 327686 ##(Smalltalk.Color) #default 328198 ##(Smalltalk.Point) 1201 901 549 nil nil nil 416 788230 ##(Smalltalk.BorderLayout) 1 1 410 ##(Smalltalk.ContainerView) 34 15 nil 416 34 2 8 1140850688 131073 560 nil 466 #face3d nil 7 nil nil nil 560 1180166 ##(Smalltalk.ProportionalLayout) 170 176 8 #() false 170 192 688 nil 983302 ##(Smalltalk.MessageSequence) 138 144 34 1 721670 ##(Smalltalk.MessageSend) #createAt:extent: 34 2 498 1 1 498 1169 49 560 983302 ##(Smalltalk.WINDOWPLACEMENT) 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 0 0 0 0 0 0 0 0 72 2 0 0 24 0 0 0] 34 1 410 ##(Smalltalk.Toolbar) 34 25 nil 560 34 2 8 1409288972 131137 928 nil 480 nil 519 nil 263174 ##(Smalltalk.Font) nil true 459014 ##(Smalltalk.LOGFONT) 8 #[243 255 255 255 0 0 0 0 0 0 0 0 0 0 0 0 144 1 0 0 0 0 0 0 3 2 1 34 65 114 105 97 108 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] 498 193 193 nil 928 480 8 1607642496 170 192 688 170 192 34 8 32085 1115206 1 ##(Smalltalk.ToolbarIconButton) 928 1 1180998 4 ##(Smalltalk.CommandDescription) #addObject 8 'Add Object' 1 1 263494 3 ##(Smalltalk.Icon) nil true 1572870 ##(Smalltalk.ImageRelativeFileLocator) 8 'icons\CompiledMethod.ico' nil 32085 32083 1154 928 1 1186 #removeObjects 8 'Remove Objects' 1 1 1234 nil true 1280 8 'icons\False.ico' nil 32083 32081 1154 928 1 1186 #getNextObject 8 'Dive' 1 1 1234 nil true 1280 8 'HistoryForward.ico' 2032142 ##(Smalltalk.STBExternalResourceLibraryProxy) 8 'dolphindr7.dll' nil 32081 32079 1154 928 1 1186 #getPreviousObject 8 'Back' 1 1 1234 nil true 1280 8 'HistoryBack.ico' 1488 32079 34 5 1520 1392 1049158 1 ##(Smalltalk.ToolbarSeparator) 928 1 1312 1168 nil nil 1 nil 498 33 33 498 45 45 nil 656198 1 ##(Smalltalk.FlowLayout) 1 1 1 722 138 144 34 1 786 #createAt:extent: 34 2 498 1 1 498 1169 49 928 866 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 0 0 0 0 0 0 0 0 72 2 0 0 24 0 0 0] 8 #() 498 193 193 nil 27 1872 nil 27 410 ##(Smalltalk.ContainerView) 34 15 nil 416 34 2 8 1140850688 131073 1888 nil nil nil 7 nil nil nil 1888 nil 170 192 34 2 410 ##(Smalltalk.MultilineTextEdit) 34 16 nil 1888 34 2 8 1140855044 65 1984 721990 2 ##(Smalltalk.ValueHolder) nil false 1310726 ##(Smalltalk.EqualitySearchPolicy) nil nil nil 7 nil nil nil 1984 nil 8 1607675312 852486 ##(Smalltalk.NullConverter) nil nil 11 722 138 144 34 3 786 #createAt:extent: 34 2 498 1 1 498 1169 47 1984 786 #text: 34 1 8 'Static Text' 1984 786 #setMarginWidths: 34 1 8 #(3 3) 1984 866 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 0 0 0 0 0 0 0 0 72 2 0 0 23 0 0 0] 8 #() 1872 nil 27 8 'statusText' nil 722 138 144 34 1 786 #createAt:extent: 34 2 498 1 729 498 1169 51 1888 866 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 0 0 0 0 108 1 0 0 72 2 0 0 133 1 0 0] 34 1 1984 1872 nil 27 nil nil 410 ##(Smalltalk.ContainerView) 34 15 nil 416 34 2 8 1140850688 131073 2592 nil 624 nil 7 nil nil nil 2592 642 170 176 34 4 410 ##(Smalltalk.ListBox) 34 17 nil 2592 34 2 8 1144064257 1025 2704 590662 2 ##(Smalltalk.ListModel) 138 144 688 nil 1310726 ##(Smalltalk.IdentitySearchPolicy) 480 nil 7 265030 4 ##(Smalltalk.Menu) nil true 34 9 984134 2 ##(Smalltalk.CommandMenuItem) 1 1186 #removeObjects 8 'Remove Objects' 1 1 nil nil nil 2898 1 1186 #addObject 8 'Add Object' 1 1 nil nil nil 983366 1 ##(Smalltalk.DividerMenuItem) 4097 2898 1 1186 #displayMore 8 'Display More' 1025 1 nil nil nil 2898 1 1186 #displayAll 8 'Display All' 1 1 nil nil nil 3010 4097 2898 1 1186 #inspectInNewWindow 8 'Inspect' 1 1 nil nil nil 2898 1 1186 #inspectKeyInNewWindow 8 'Inspect Key' 1 1 nil nil nil 2898 1 1186 #inspectBytes 8 'Inspect Bytes' 1 1 nil nil nil 8 '' nil 134217729 nil nil nil nil nil nil nil 2704 nil 8 1607482368 459270 ##(Smalltalk.Message) #key 8 #() 8 #() nil 722 138 144 34 4 786 #createAt:extent: 34 2 498 1 1 498 387 681 2704 786 #contextMenu: 34 1 2864 2704 786 #caretIndex: 8 #(1) 2704 786 #horizontalExtent: 8 #(0) 2704 866 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 0 0 0 0 0 0 0 0 193 0 0 0 84 1 0 0] 8 #() 1872 nil 27 3 410 ##(Smalltalk.ReferenceView) 34 14 nil 2592 34 2 8 1140850688 131073 3648 nil 480 nil 7 nil nil nil 3648 1180230 1 ##(Smalltalk.ResourceIdentifier) ##(Smalltalk.CodeSourcePresenter) #resource_Default_view nil 722 138 144 34 1 786 #createAt:extent: 34 2 498 397 1 498 773 681 3648 866 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 198 0 0 0 0 0 0 0 72 2 0 0 84 1 0 0] 688 1872 nil 27 5 false 170 192 34 4 2704 8 'instVarList' 3648 8 'codePane' nil 722 138 144 34 1 786 #createAt:extent: 34 2 498 1 49 498 1169 681 2592 866 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 0 0 0 0 24 0 0 0 72 2 0 0 108 1 0 0] 34 3 2704 410 ##(Smalltalk.Splitter) 34 12 nil 2592 34 2 8 1140850688 1 4112 nil 480 nil 519 nil nil nil 1510470 1 ##(Smalltalk.DraggableViewInteractor) 4112 nil 1 #left nil nil nil 498 1 1 498 9 9 nil 4208 nil 722 138 144 34 1 786 #createAt:extent: 34 2 498 387 1 498 11 681 4112 866 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 193 0 0 0 0 0 0 0 198 0 0 0 84 1 0 0] 8 #() 1872 nil 27 3648 1872 nil 27 170 192 688 nil 461638 4 ##(Smalltalk.MenuBar) nil true 34 2 2850 nil true 34 15 2898 1 1186 #undo 8 '&Undo' 9397 1 nil nil nil 2898 1 1186 #redo 8 'R&edo' 9395 1 nil nil nil 3010 4097 2898 1 1186 #editCut 8 'Cu&t' 9393 1 nil nil nil 2898 1 1186 #editCopy 8 '&Copy' 9351 1 nil nil nil 2898 1 1186 #editPaste 8 '&Paste' 9389 1 nil nil nil 2898 1 1186 #editSelectAll 8 'Select &All' 9347 1 nil nil nil 2898 1 1186 #editDelete 8 '&Delete' 1629 1 nil nil nil 3010 4097 2898 1 1186 #editFind 8 '&Find...' 9357 1 nil nil nil 2898 1 1186 #editFindNext 8 'Find &Next' 9359 1 nil nil nil 2898 1 1186 #editReplace 8 '&Replace...' 9361 1 nil nil nil 3010 4097 2898 1 1186 #addQuotesToSelection 8 'Add &Quotes' 1 1 nil nil nil 2898 1 1186 #removeQuotesFromSelection 8 'Re&move Quotes' 1 1 nil nil nil 8 '&Edit' nil 1 nil nil 32135 nil nil 2850 nil true 34 13 2898 1 1186 #abortTransaction 8 '&Abort Transaction' 1 1 nil nil nil 2898 1 1186 #commitTransaction 8 '&Commit Transaction' 1 1 nil nil nil 3010 4097 2898 1 1186 #jadeInspect 8 '&Inspect' 9379 1 nil nil nil 2898 1 1186 #jadeDisplay 8 '&Display' 9353 1 nil nil nil 2898 1 1186 #jadeExecute 8 '&Execute' 9355 1 nil nil nil 2898 1 1186 #jadeDebug 8 'De&bug' 9349 1 nil nil nil 2898 1 1186 #fileIn 8 'Fi&le In' 1 1 nil nil nil 3010 4097 2898 1 1186 #browseClass 8 '&Browse Class' 9377 1 nil nil nil 3010 4097 2898 1 1186 #displayMore nil 1025 1 nil nil nil 2898 1 1186 #displayAll nil 1 1 nil nil nil 8 '&Jadeite' nil 1 nil nil 32157 nil nil 8 '' nil 1 nil nil nil nil nil nil nil nil 1 nil nil nil nil 1 nil nil 722 138 144 34 2 786 #createAt:extent: 34 2 498 6447 21 498 1201 901 416 786 #text: 34 1 8 'Jade Object Navigation Inspector' 416 866 8 #[44 0 0 0 0 0 0 0 0 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 151 12 0 0 10 0 0 0 239 14 0 0 204 1 0 0] 34 3 560 2592 1888 1872 nil 27 )
]

{ #category : 'as yet unclassified' }
JadeiteInspector class >> showOn: oop session: aGciSession [
	| inspector |
	inspector := self new gciSession: aGciSession.
	^inspector inspect: oop inContext: aGciSession oopNil
]

{ #category : 'as yet unclassified' }
JadeiteInspector >> aboutToChange: aSelectionChangingEvent [
	aSelectionChangingEvent value ifTrue: [
		aSelectionChangingEvent value: self isOkayToChange.
	].

]

{ #category : 'as yet unclassified' }
JadeiteInspector >> addObject [
	| string |
	"might have inserted a string into another string so it won't find the object"
	model isVariable ifFalse: [^MessageBox notify: 'Cannot add elements to this object'].
	string := Prompter
				on: String new asValue
				prompt: 'Entry will be compiled and added to the object'
				caption: 'Add Object ...'.
	string ifNil: [^self].
	model isDictionary ifTrue: [^self basicAddKey: string].
	self basicAddObject: string
]

{ #category : 'as yet unclassified' }
JadeiteInspector >> addOop: oop [
	codePane context: oop. 
	oop isNil ifTrue: [^self].
	(oopsCollection includes: oop) ifTrue: [^self].
	oopsCollection add: oop.
	objectIndex := objectIndex + 1
]

{ #category : 'adding' }
JadeiteInspector >> addStyle: aString [

	codePane addStyle: aString.
	
]

{ #category : 'as yet unclassified' }
JadeiteInspector >> additionalAccelerators [
	^super additionalAccelerators
		, #(#(#fileSave 'Ctrl+S') #(#selectAll 'Ctrl+A') #(#jadeDebug 'Ctrl+B'))
]

{ #category : 'as yet unclassified' }
JadeiteInspector >> basicAddKey: string [
	| addedObject newSelectionIndex |
	"might have inserted a string into another string so it won't find the object"
	model
		command: #addKey:;
		commandArgs: (Array with: string).
	self issueCommand: model.
	addedObject := model objects
				detect: [:assoc | (assoc value isKindOf: Array) and: [assoc value first = model selectionOop]]
				ifNone: [].
	newSelectionIndex := model objects indexOf: addedObject.
	newSelectionIndex := newSelectionIndex + 2. "inst vars & dynamic inst vars already included in objects" 
	self displayObjectSelecting: newSelectionIndex
]

{ #category : 'as yet unclassified' }
JadeiteInspector >> basicAddObject: string [
	| addedObject additionIndex newSelectionIndex |
	additionIndex := (self indexedOffsetFromInstVarList: instVarListPresenter selectionsByIndex) first.
	model
		command: #addObject:after:;
		commandArgs: (Array with: string with: additionIndex).
	self issueCommand: model.
	addedObject := model objects detect: [:assoc | assoc value = model selectionOop] ifNone: [].
	newSelectionIndex := model objects indexOf: addedObject.
	newSelectionIndex := newSelectionIndex = 0
				ifTrue: [1	"might have inserted a string into another string so it won't find the object"]
				ifFalse: [newSelectionIndex + 2].
	self displayObjectSelecting: newSelectionIndex
]

{ #category : 'as yet unclassified' }
JadeiteInspector >> basicRemoveDynamicInstVars [
	"remove dynamics, but let sender remove non-dynamics"

	| dynamicInstVarNames firstSelectionIndex nonDynamicsWereSelected selectionIndicesOfDynamics |
	firstSelectionIndex := instVarListPresenter selectionsByIndex first.
	selectionIndicesOfDynamics := instVarListPresenter selectionsByIndex
				select: [:index | '--*' match: (instVarListPresenter list at: index) key].
	dynamicInstVarNames := self selectedDynamicInstVars.
	nonDynamicsWereSelected := instVarListPresenter selections size - dynamicInstVarNames size > 0.
	model removeDynamicInstVarsNamed: dynamicInstVarNames session: gciSession.
	instVarListPresenter view
		selectionsByIndex: (instVarListPresenter selectionsByIndex difference: selectionIndicesOfDynamics).
	nonDynamicsWereSelected ifFalse: [self displayObjectSelecting: firstSelectionIndex - 1].
	^nonDynamicsWereSelected
]

{ #category : 'as yet unclassified' }
JadeiteInspector >> basicRemoveFromDictionary [
	| selections newSelectionIndex |
	selections := instVarListPresenter selections collect: [:sel | sel value at: 1].
	self model removeKeys: selections session: gciSession.
	newSelectionIndex := instVarListPresenter view selectionsByIndex first min: model objects size + 2.
	self displayObjectSelecting: newSelectionIndex.
	(oopsCollection intersection: selections) do: 
			[:removedOop |
			oopsCollection remove: removedOop.
			objectIndex := objectIndex - selections size]
]

{ #category : 'as yet unclassified' }
JadeiteInspector >> basicRemoveObjects [
	| indices |
	model instVarsAreRemovable ifFalse: [^self].
	self isDynamicInstVarSelected
		ifTrue: [self basicRemoveDynamicInstVars ifFalse: [^self]	"might need to remove other elements"].
	indices := instVarListPresenter selectionsByIndex.
	model isDictionary ifTrue: [^self basicRemoveFromDictionary].
	self isNamedInstVarSelected ifTrue: [^MessageBox notify: 'Cannot remove inst var'].	"inst var"
	model isUnordered ifTrue: [^self basicRemoveOop: instVarListPresenter selection value].
	indices first - model instVarNames size <= 0 ifTrue: [^self].
	self basicRemoveObjectsAt: indices
]

{ #category : 'as yet unclassified' }
JadeiteInspector >> basicRemoveObjectsAt: indices [
	| selections newSelectionIndex |
	selections := instVarListPresenter selections.
	model removeIndexedInstVarsAt: (self indexedOffsetFromInstVarList: indices) session: gciSession.
	newSelectionIndex := indices first
				min: model indexedSize + model instVarNames size + self dynamicInstVars size + 2.
	self displayObjectSelecting: newSelectionIndex.
	(selections collect: [:sel | sel value]) do: 
			[:oop |
			(oopsCollection includes: oop)
				ifTrue: 
					[oopsCollection remove: oop.
					objectIndex := objectIndex - 1]]
]

{ #category : 'as yet unclassified' }
JadeiteInspector >> basicRemoveOop: oop [
	| selection selectionIndex |
	selection := instVarListPresenter selection.
	self model removeOop: oop session: gciSession.
	selectionIndex := instVarListPresenter selectionByIndex min: model objects size + 2.
	self displayObjectSelecting: selectionIndex.
	oopsCollection remove: selection value ifAbsent: [^self].
	objectIndex := objectIndex - 1
]

{ #category : 'browsing' }
JadeiteInspector >> browseClass [
	| shell classService |
	classService := RowanClassService new name: className subStrings first.	"strip off 'class' if meta"
	BrowserUpdate current updateService: classService session: gciSession.
	shell := JadeiteBrowser showOnSession: gciSession.
	shell currentCard updateAfterFindClass: classService.
	^shell
]

{ #category : 'as yet unclassified' }
JadeiteInspector >> canSave [
	^instVarListPresenter selections size = 1
		and: [self isSelfSelected not and: [self isAsOopSelected not]]
]

{ #category : 'as yet unclassified' }
JadeiteInspector >> computedListSelections [
	^instVarListPresenter selections difference: self nonComputedListSelections
]

{ #category : 'initialization' }
JadeiteInspector >> connectPresenters [

	instVarListPresenter whenSelectionChangedDo: [ :selection | 
		self selectedInstVar ].
	instVarListPresenter whenActivatedDo: [ :selection | 
		self inspectInstVar ]
]

{ #category : 'as yet unclassified' }
JadeiteInspector >> contextObject [
	^model oop
]

{ #category : 'as yet unclassified' }
JadeiteInspector >> createComponents [

	super createComponents. 
	statusTextPresenter := self add: TextPresenter new name: 'statusText'.

]

{ #category : 'as yet unclassified' }
JadeiteInspector >> createSchematicWiring [
	super createSchematicWiring.
	instVarListPresenter
		when: #selectionChanging:
		send: #aboutToChange:
		to: self
]

{ #category : 'initialization' }
JadeiteInspector >> defaultLayout [ 

	^SpBoxLayout newVertical
]

{ #category : 'as yet unclassified' }
JadeiteInspector >> displayAll [
	^self displayMore: model indexedSize
]

{ #category : 'as yet unclassified' }
JadeiteInspector >> displayMore [
	^self displayMore: model maxIndexedVars + model visibleIndices
]

{ #category : 'displaying' }
JadeiteInspector >> displayMore: stop [
	| service |
	service := RowanInspectorService new
				oop: model oop;
				indexedSize: model indexedSize.
	service
		nextIndexedVarsFrom: model visibleIndices + 1
		to: stop
		session: gciSession.
	model objects addAll: service nextIndices.
	model visibleIndices: service visibleIndices.
	self displayObjectSelecting: instVarListPresenter selectionByIndex
]

{ #category : 'displaying' }
JadeiteInspector >> displayObjectSelecting: selectionIndex [
	| contents reachedMax |
	contents := model objects copy.	"otherwise the presenter list will notice it's the same object and not update the view"
	(contents isEmpty or: [contents first ~= model myself])
		ifTrue: 
			[contents addFirst: (Array with: '-.asOop' with: model oop printString).
			contents addFirst: model myself].
	instVarListPresenter list: (ListModel on: contents).
	instVarListPresenter selectIndex: (selectionIndex ifNil: [1] ifNotNil: [selectionIndex]).
	reachedMax := model visibleIndices = self maxVariables
				ifTrue: [' (max displayable)']
				ifFalse: [String new].
	model statusText
		ifNil: 
			[model indexedSize > 0
				ifTrue: 
					[statusTextPresenter
						value: 'Displaying ' , model visibleIndices printString , reachedMax , ' of '
								, model indexedSize printString
									, (model isDictionary ifTrue: [' keys'] ifFalse: [' variable inst vars'])]
				ifFalse: [statusTextPresenter value: nil]]
		ifNotNil: [statusTextPresenter value: model statusText].
	className := model className.
	"documentPresenter view isModified: false"
]

{ #category : 'as yet unclassified' }
JadeiteInspector >> dynamicInstVars [
	^instVarListPresenter list select: [:instVar | '--*' match: instVar key]
]

{ #category : 'as yet unclassified' }
JadeiteInspector >> editRevert [
	self selectedInstVar
]

{ #category : 'as yet unclassified' }
JadeiteInspector >> evaluateSelectedTextIn: textPresenter thenInspectInContext: context [
	| service |
	service := self evaluateText: textPresenter currentSelectionOrLine thenInspectInContext: context.
	service compileErrorArray
		ifNotNil: 
			[[^textPresenter showCompileError: service compileErrorArray first]
				ensure: [service compileErrorArray: nil]].
	^self showOn: service
]

{ #category : 'evaluating' }
JadeiteInspector >> evaluateSelectedTextIn: textPresenter thenInspectInContext: context debugger: debugger [
	| service |
	self createView: self class defaultView.
	service := RowanInspectorService new
				executeThenInspect: textPresenter currentSelectionOrLine
				context: context
				session: gciSession
				windowHandle: self view handle value
				debugger: debugger.
	service compileErrorArray
		ifNotNil: 
			[
			[self view close.
			^textPresenter showCompileError: service compileErrorArray first]
					ensure: [service compileErrorArray: nil]].
	^self showOn: service
]

{ #category : 'evaluating' }
JadeiteInspector >> evaluateText: string thenInspectInContext: context [
	| service |
	self createView: self class defaultView.
	service := RowanInspectorService new
				executeThenInspect: string
				context: context
				session: gciSession
				windowHandle: self view handle value.
	^service
]

{ #category : 'as yet unclassified' }
JadeiteInspector >> executeThenInspect: aString inContext: context [
	| service window |
	window := self asWindow.
	service := RowanInspectorService new
				executeThenInspect: aString 
				context: context
				session: gciSession
				windowHandle: window identityHash.
	service compileErrorArray ifNotNil: [ SyntaxErrorNotification
			inClass: Object
			withCode: aString
			doitFlag: false
			errorMessage: (service compileErrorArray first at: 3)
			location: (service compileErrorArray first at: 2) ].
	^self show: window on: service
]

{ #category : 'as yet unclassified' }
JadeiteInspector >> expectedModelClass [
	^RowanInspectorService
]

{ #category : 'accessing' }
JadeiteInspector >> gciSession [ 
	
	^self application gciSession
]

{ #category : 'navigation' }
JadeiteInspector >> getNextObject [

	objectIndex := (objectIndex >= oopsCollection size) 
				ifTrue: [1]
				ifFalse:[objectIndex + 1].

	self setNewInspectedObject.
]

{ #category : 'navigation' }
JadeiteInspector >> getPreviousObject [
	objectIndex := (objectIndex <= 1) 
				ifTrue: [oopsCollection size]
				ifFalse:[objectIndex - 1].

	self setNewInspectedObject.
]

{ #category : 'as yet unclassified' }
JadeiteInspector >> indexedOffsetFromInstVarList: indices [
	^indices
		collect: [:index | index - model instVarNames size - self dynamicInstVars size - 2 max: 0	"2 = self + asOop"]
]

{ #category : 'initialization' }
JadeiteInspector >> initialize [

	super initialize.
	oopsCollection := OrderedCollection new.
	objectIndex := 0
]

{ #category : 'initialization' }
JadeiteInspector >> initializeInstVarList: box [

	instVarListPresenter := (JadeiteListPresenter new display: #first)
		                        beMultipleSelection.
	instVarListPresenter contextMenu: [ 
		SpMenuPresenter new
			addItem: [ :item | 
				item
					name: 'Dive';
					action: [ self inspectInstVar ];
					enabled:
						(self isSelectionComputed: instVarListPresenter selectedItem) not];
			addItem: [ :item | 
				item
					name: 'Inspect';
					action: [ 
						JadeiteInspectorApplication
							show: instVarListPresenter selectedItem last
							onSession: gciSession library ];
					enabled:
						(self isSelectionComputed: instVarListPresenter selectedItem) not] ].
	box add: instVarListPresenter
]

{ #category : 'initialization' }
JadeiteInspector >> initializePresenters [

	| box |
	super initializePresenters.
	self initializeToolbar.
	box := SpBoxLayout newHorizontal.
	box spacing: 10.
	self layout add: box.
	self initializeInstVarList: box.
	box add:
		(documentPresenter := codePane := JadeiteTextDocument new _gciSession:
			                                  self gciSession).
	statusTextPresenter := self newStatusBar.
	self layout addLast: statusTextPresenter expand: false
]

{ #category : 'initialization' }
JadeiteInspector >> initializeToolbar [

	toolbar := self newJadeiteToolbar
		           addItem: (SpToolbarButtonPresenter new
				            label: 'Back';
				            icon: (self iconNamed: #glamorousLeft);
				            help: 'returns to previous inspected object';
				            action: [ self getPreviousObject ];
				            yourself);
		           addItem: (SpToolbarButtonPresenter new
				            label: 'Dive';
				            icon: (self iconNamed: #glamorousRight);
				            help: 'dives into selected object';
				            action: [ self inspectInstVar ];
				            yourself);
		           yourself.
	self layout
		add: #toolbar
		expand: false
		fill: false
		padding: 0
]

{ #category : 'initialization' }
JadeiteInspector >> initializeWindow: aWindowPresenter [

	super initializeWindow: aWindowPresenter.
	aWindowPresenter initialExtent: 800 @ 500.
	self updateCaption.
]

{ #category : 'inspecting' }
JadeiteInspector >> inspect: oop inContext: context [
	| service window |
	window := self asWindow.
	service := RowanInspectorService new
				inspect: oop
				session: gciSession
				inWindow: window identityHash.
	^self show: window on: service
]

{ #category : 'as yet unclassified' }
JadeiteInspector >> inspectBytes [
	| inspector |
	inspector := JadeiteInspector new gciSession: gciSession.
	^inspector inspectBytes: (OopType64 fromInteger: oopsCollection first)
		inContext: gciSession oopNil value
]

{ #category : 'as yet unclassified' }
JadeiteInspector >> inspectBytes: oop inContext: context [
	| service |
	self createView: self class defaultView.
	service := RowanInspectorService new
				inspectBytes: oop
				session: gciSession
				inWindow: self view handle value.
	^self showOn: service
]

{ #category : 'as yet unclassified' }
JadeiteInspector >> inspectInNewWindow [
	| inspector key oop |
	inspector := JadeiteInspector new gciSession: gciSession.
	oop := instVarListPresenter selections first value.
	key := instVarListPresenter selections first key.
	key = 'self' ifTrue: [oop := model oop].
	key = '-.asOop' ifTrue: [oop := oop asNumber].
	(oop isKindOf: Array) ifTrue: [oop := oop last].
	^inspector inspect: (OopType64  fromInteger: oop) inContext: gciSession oopNil value
]

{ #category : 'as yet unclassified' }
JadeiteInspector >> inspectInstVar [
	| oop |
	"instVarListPresenter selection is <anAssociation>"
	(self isSelfSelected or:[self isAsOopSelected]) ifTrue:[^self]. 
	oop := instVarListPresenter selections first value.
	(oop isKindOf: Array) ifTrue: [oop := oop last].	"a dictionary entry will hold oop of key and oop of value"
	objectIndex = oopsCollection size
		ifFalse: [(oopsCollection at: objectIndex + 1) = oop ifTrue: [^self getNextObject]].
	self inspectOop: oop
]

{ #category : 'as yet unclassified' }
JadeiteInspector >> inspectKeyInNewWindow [
	| inspector key oop |
	inspector := JadeiteInspector new gciSession: gciSession.
	oop := instVarListPresenter selections first value.
	key := instVarListPresenter selections first key.
	key = 'self' ifTrue: [oop := model oop].
	key = '-.asOop' ifTrue: [oop := oop asNumber].
	(oop isKindOf: Array) ifTrue: [oop := oop first].	"for dictionaries with real keys"
	^inspector inspect: (OopType64 fromInteger: oop) inContext: gciSession oopNil value
]

{ #category : 'as yet unclassified' }
JadeiteInspector >> inspectOop: oop [
	| service |
	service := RowanInspectorService new
				inspect: oop
				session: gciSession
				inWindow: self owner identityHash.
	model := service.
	self addOop: oop.
	self todo:["needed?" self setDocumentPresenterLabel].
	self displayObjectSelecting: nil.
	self updateCaption
]

{ #category : 'as yet unclassified' }
JadeiteInspector >> instVarListIndexFromIndexedOffset: index [
	^index + model instVarNames size + self dynamicInstVars size + 2	"2 = self + asOop"
]

{ #category : 'as yet unclassified' }
JadeiteInspector >> isAsOopSelected [
	^(instVarListPresenter selections detect: [:assoc | assoc key = '-.asOop'] ifNone: []) notNil
]

{ #category : 'as yet unclassified' }
JadeiteInspector >> isDynamicInstVarSelected [
	instVarListPresenter selections isEmpty ifTrue: [^false].
	^'--*' match: instVarListPresenter selections first key
]

{ #category : 'as yet unclassified' }
JadeiteInspector >> isNamedInstVarSelected [
	^model instVarNames includesAnyOf: self selectedNamedInstVars
]

{ #category : 'as yet unclassified' }
JadeiteInspector >> isOkayToChange [
	documentPresenter view isModified
		ifTrue: [^JadePresenter unsavedChangesDialogIn: documentPresenter].
	documentPresenter view isModified: false.
	^true
]

{ #category : 'as yet unclassified' }
JadeiteInspector >> isProtectedItemSelected [
	instVarListPresenter selections isEmpty ifTrue: [^false].
	(instVarListPresenter selectionsByIndex includesAnyOf: #(1 2)) ifTrue: [^true].
	instVarListPresenter selections
		do: [:selection | (('-*' match: selection key) and: [('--*' match: selection key) not]) ifTrue: [^true]].
	^false
]

{ #category : 'as yet unclassified' }
JadeiteInspector >> isSelectionComputed: assoc [
	^assoc key = 'self' or: [assoc key = '-.asOop']
]

{ #category : 'as yet unclassified' }
JadeiteInspector >> isSelfSelected [
	^instVarListPresenter selections first key = 'self'
]

{ #category : 'as yet unclassified' }
JadeiteInspector >> isStringObject [

	^true
]

{ #category : 'constants' }
JadeiteInspector >> maxPrintStringSize [
	^JadePresenter maxPrintStringSize
]

{ #category : 'as yet unclassified' }
JadeiteInspector >> maxVariables [
	"sync with server method RowanInspectorService>>maxVariables"

	^65000
]

{ #category : 'menus' }
JadeiteInspector >> menuCommandClasses [

	^{JadeiteInspectInstVarCommand}
]

{ #category : 'menus' }
JadeiteInspector >> menuCommandGroup [

	| group |
	group := CmCommandGroup forSpec
		  beRoot;
			yourself.
	self menuCommands do: [:command | group register: command].
	^group
]

{ #category : 'menus' }
JadeiteInspector >> menuCommands [

	^self menuCommandClasses
		collect:
			[:each |
			(each forSpecContext: self)
				iconProvider: SpkIconLibrary current;
				yourself]
]

{ #category : 'as yet unclassified' }
JadeiteInspector >> multipleInstVarsSelected [
	| writeStream oops answeringService computedSelections contents boldNeeded |
	"documentPresenter view stylerClass: NullScintillaStyler."
	writeStream := WriteStream on: String new.
	oops := self valueOops.
	answeringService := RowanAnsweringService new.
	answeringService
		command: #printStringOfOops:toMaxSize:;
		commandArgs: (Array with: oops with: self maxPrintStringSize).
	BrowserUpdate current issueCommand: answeringService session: gciSession. 
	computedSelections := self computedListSelections.
	boldNeeded := OrderedCollection new.
	computedSelections do: 
			[:assoc |
			boldNeeded add: (writeStream position to: writeStream position + assoc key size).
			writeStream
				nextPutAll: assoc key;
				nextPut: $:;
				space;
				nextPutAll: assoc last;
				cr].
	1 to: oops size
		do: 
			[:index |
			| key |
			key := (instVarListPresenter selections at: index + computedSelections size) key.
			boldNeeded add: (writeStream position to: writeStream position + key size).
			writeStream
				nextPutAll: key;
				nextPut: $:;
				space;
				nextPutAll: (answeringService answer at: index).
			index = oops size ifFalse:[
				writeStream cr]].
	contents := writeStream contents.
	contents last = Character lf
		ifTrue: [contents := contents copyFrom: 1 to: contents size - 2	"crlf"].
	documentPresenter value: contents.
"	documentPresenter view removeAllStyling.
	boldNeeded do: 
			[:interval |
			documentPresenter view startStylingFrom: interval start.
			documentPresenter view applyStyle: #literalArray toNext: interval size	'serves as a cheap way to get bold text']"
]

{ #category : 'initialization' }
JadeiteInspector >> newStatusBar [

	^ self instantiate: JadeiteStatusBarPresenter
]

{ #category : 'as yet unclassified' }
JadeiteInspector >> nonComputedListSelections [
	| computedSelections |
	computedSelections := instVarListPresenter selectedItemsSorted
				reject: [:assoc | self isSelectionComputed: assoc].
	^computedSelections
]

{ #category : 'accessing' }
JadeiteInspector >> objectIndex [

	^ objectIndex
]

{ #category : 'accessing' }
JadeiteInspector >> objectIndex: anObject [

	^ objectIndex := anObject
]

{ #category : 'as yet unclassified' }
JadeiteInspector >> objectIsVariable [
	| answeringService |
	model command: #isVariable.
	answeringService := BrowserUpdate current issueCommands: (Array with: self) session: gciSession.
	^answeringService answer
]

{ #category : 'as yet unclassified' }
JadeiteInspector >> onCloseRequested: boolValueHolder [
	self isOkayToChange ifFalse:[boolValueHolder value: false]. 
]

{ #category : 'accessing' }
JadeiteInspector >> oopsCollection [

	^ oopsCollection
]

{ #category : 'accessing' }
JadeiteInspector >> oopsCollection: anObject [

	oopsCollection := anObject
]

{ #category : 'printing' }
JadeiteInspector >> printInstVar [

	| answeringService oop theValue |
	^ [ 
	  answeringService := RowanAnsweringServiceClient new registerWith:
		                      gciSession library.
	  theValue := instVarListPresenter selectedItems first last. "oop or Array"
	  oop := (theValue isKindOf: Array)
		         ifTrue: [ theValue at: 2 ]
		         ifFalse: [ theValue ].
	  answeringService
		  command: #printStringOf:toMaxSize:;
		  commandArgs: (Array with: oop with: self maxPrintStringSize).
	  BrowserUpdate current issueCommand: answeringService session: gciSession. 
	  answeringService answer ]
		  on: Error
		  do: [ :ex | 
			  self
				  displayInstVarError: ex
				  instVar: instVarListPresenter selectedItems first last ]
]

{ #category : 'as yet unclassified' }
JadeiteInspector >> queryCommand: query [
	| command |
	command := query command.
	command = #fileSave
		ifTrue: 
			[self shouldEnableFileSave: query.
			^true].
	(command = #displayMore or: [command = #displayAll])
		ifTrue: 
			[model isShowingAllIndexedVars
				ifTrue: 
					[query isEnabled: false.
					^true]].
	command = #addObject
		ifTrue: 
			[model isService ifTrue: [query isEnabled: model isVariable].
			^true].
	command = #removeObjects
		ifTrue: 
			[self isProtectedItemSelected
				ifTrue: 
					[query isEnabled: false.
					^true]].
	command = #inspectInNewWindow
		ifTrue: 
			[query isEnabled: instVarListPresenter selections size = 1.
			^true].
	command = #inspectKeyInNewWindow
		ifTrue: 
			[| selections |
			selections := instVarListPresenter selections.
			query isEnabled: (selections size = 1 and: [selections first value isKindOf: Array]).
			^true].
	command = #inspectBytes
		ifTrue: 
			[query isEnabled: (model isStringObject ifNil:[false]).
			^true].
	query command == #getPreviousObject
		ifTrue: 
			[query isEnabled: objectIndex ~= 1.
			^true].
	query command == #getNextObject
		ifTrue: 
			[query isEnabled: objectIndex < oopsCollection size.
			^true].
	(query command == #browseClass or: [query command == #browseSelectedClass])
		ifTrue: 
			[query isEnabled: true.
			^true].
]

{ #category : 'as yet unclassified' }
JadeiteInspector >> registerWindow: handle rootObject: oop [
	^RowanBrowserService new
		registerWindow: handle value
		rootObject: oop
		session: self gciSession
]

{ #category : 'actions' }
JadeiteInspector >> removeObject [

	(oopsCollection size > 1) ifFalse: [^self].

	oopsCollection remove: self model value ifAbsent: [^self].

	objectIndex := (objectIndex <= 1) 
				ifTrue: [oopsCollection size]
				ifFalse:[objectIndex - 1].

	self setNewInspectedObject.

]

{ #category : 'as yet unclassified' }
JadeiteInspector >> removeObjects [
	(MessageBox confirm: 'Really remove selection(s)?') ifFalse: [^self].
	^self basicRemoveObjects
]

{ #category : 'as yet unclassified' }
JadeiteInspector >> reportCompileError: ex [
	| position text |
	text := (ex list first at: 3) , '>>>>>'.
	position := ex list first at: 2.
	documentPresenter view caretPosition: position.
	documentPresenter view insertText: text at: position.
	^documentPresenter view selectionRange: (position to: position + text size - 1)
]

{ #category : 'as yet unclassified' }
JadeiteInspector >> saveDictionaryElement [
	| keyOop |
	keyOop := instVarListPresenter selection value first.
	model
		command: #saveKey:value:;
		commandArgs: (Array with: keyOop with: documentPresenter value).
	self issueCommand: model.
	self displayObjectSelecting: instVarListPresenter selectionByIndex
]

{ #category : 'as yet unclassified' }
JadeiteInspector >> saveDocument [
	(self isSelfSelected or: [self isAsOopSelected])
		ifTrue: [^MessageBox notify: 'Cannot modify Self or the oop'].
	
	[self isDynamicInstVarSelected ifTrue: [^self saveDynamicInstVar].
	self isNamedInstVarSelected ifTrue: [^self saveNamedInstVar].
	model isDictionary ifTrue: [^self saveDictionaryElement].
	model isUnordered ifTrue: [^self saveUnorderedElement].
	self saveIndexedElement]
			on: GsCompileError
			do: [:ex | self reportCompileError: ex]
]

{ #category : 'as yet unclassified' }
JadeiteInspector >> saveDynamicInstVar [
	| instVarName |
	instVarName := self selectedDynamicInstVars first. "only save when one object selected"
	model
		command: #save:dynamicInstVar:;
		commandArgs: (Array with: documentPresenter value with: instVarName).
	self issueCommand: model. 
	self displayObjectSelecting: instVarListPresenter selectionByIndex
]

{ #category : 'as yet unclassified' }
JadeiteInspector >> saveIndexedElement [
	| indices |
	indices := self indexedOffsetFromInstVarList: instVarListPresenter selectionsByIndex.	"should always be one if we get here"
	model
		command: #save:indexedVarAt:;
		commandArgs: (Array with: documentPresenter value with: indices first).
	self issueCommand: model.
	self displayObjectSelecting: (self instVarListIndexFromIndexedOffset: indices first)
]

{ #category : 'as yet unclassified' }
JadeiteInspector >> saveNamedInstVar [
	| index instVarName |
	instVarName := self selectedNamedInstVars first.
	model
		command: #save:namedInstVar:;
		commandArgs: (Array with: documentPresenter value with: instVarName).
	self issueCommand: model. 
	index := model instVarNames indexOf: instVarName.
	self displayObjectSelecting: index + 2
]

{ #category : 'as yet unclassified' }
JadeiteInspector >> saveUnorderedElement [
	| oop addedObject newSelectionIndex |
	oop := instVarListPresenter view selections first value.
	model
		command: #replaceElement:with:;
		commandArgs: (Array with: oop with: documentPresenter value).
	self issueCommand: model. 
	addedObject := model objects detect: [:assoc | assoc value = model selectionOop] ifNone: [].
	newSelectionIndex := model objects indexOf: addedObject.
	self displayObjectSelecting: newSelectionIndex + 2
]

{ #category : 'as yet unclassified' }
JadeiteInspector >> selectedDynamicInstVars [
	"if a named inst var is selected, return it's name as a symbol"

	^instVarListPresenter selections select: [:sel | '--*' match: sel key]
		thenCollect: [:sel | (sel key copyFrom: 3 to: sel key size) asSymbol]
]

{ #category : 'as yet unclassified' }
JadeiteInspector >> selectedInstVar [
	| string key | 
	instVarListPresenter selectedItems isEmpty
		ifTrue: 
			[codePane text: String new.
			^self].
	instVarListPresenter selectedItems size > 1 ifTrue: [ ^self multipleInstVarsSelected].
	"documentPresenter view stylerClass: SmalltalkExpressionStyler."
	key := instVarListPresenter selectedItems first first.
	(key = 'self' or: [key = '-.asOop'])
		ifTrue: 
			[codePane text: instVarListPresenter selectedItems first last.
			^self].
	 [string := self printInstVar] on: GsRuntimeError
				do: 
					[:ex |
					ex errorReport number == 2106
						ifTrue: 
							["Forward reference error"
							ex return: 'an invalid or hidden object (perhaps a LargeObjectNode)'].
					ex pass].
	codePane text: string
]

{ #category : 'as yet unclassified' }
JadeiteInspector >> selectedNamedInstVars [
	"if a named inst var is selected, return it's name as a symbol"

	^instVarListPresenter selections collect: [:assoc | (assoc key copyWithout: $-) asSymbol]
]

{ #category : 'as yet unclassified' }
JadeiteInspector >> setNewInspectedObject [
	| oop |
	oop := oopsCollection at: objectIndex.
	self inspectOop: oop
]

{ #category : 'overrides' }
JadeiteInspector >> shellName [
	| inspectionTarget |
	inspectionTarget := className ifNil: [model ifNil: [String new] ifNotNil: [model printString]].
	^'Jadeite Inspector on ' , inspectionTarget , self shellNameExtraInfo
]

{ #category : 'as yet unclassified' }
JadeiteInspector >> shouldEnableFileSave: query [
	(instVarListPresenter selectionIfNone: [])
		ifNil: [query isEnabled: false]
		ifNotNil: 
			[query
				isEnabled: (documentPresenter view isModified and: 
							[self isSelfSelected not
								and: [self isAsOopSelected not and: [instVarListPresenter selections size = 1]]])]
]

{ #category : 'displaying' }
JadeiteInspector >> show: window on: service [

	model := service.
	window open.
	self displayObjectSelecting: nil.
	self updateCaption.
	self addOop: model oop
]

{ #category : 'as yet unclassified' }
JadeiteInspector >> showOn: service [
	model := service.
	self showShell.
	self displayObjectSelecting: nil.
	self updateCaption.
	self addOop: self model oop
]

{ #category : 'as yet unclassified' }
JadeiteInspector >> statusText [
	^statusTextPresenter value
]

{ #category : 'as yet unclassified' }
JadeiteInspector >> valueOops [
	^self nonComputedListSelections
		collect: [:assoc | assoc last isNumber ifTrue: [assoc last] ifFalse: [assoc last last	"dictionary"]]
]
